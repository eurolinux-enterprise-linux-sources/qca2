<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Qt Cryptographic Architecture: QCA::SyncThread Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.3 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath"><a class="el" href="namespaceQCA.html">QCA</a>::<a class="el" href="classQCA_1_1SyncThread.html">SyncThread</a>
  </div>
</div>
<div class="contents">
<h1>QCA::SyncThread Class Reference<br/>
<small>
[<a class="el" href="group__UserAPI.html">QCA user API</a>]</small>
</h1><!-- doxytag: class="QCA::SyncThread" --><!-- doxytag: inherits="QThread" -->
<p>Convenience class to run a thread and interact with it synchronously.  
<a href="#_details">More...</a></p>

<p><code>#include &lt;<a class="el" href="qca__support_8h_source.html">QtCrypto</a>&gt;</code></p>
<div class="dynheader">
Collaboration diagram for QCA::SyncThread:</div>
<div class="dynsection">
<div class="center"><img src="classQCA_1_1SyncThread__coll__graph.png" border="0" usemap="#QCA_1_1SyncThread_coll__map" alt="Collaboration graph"/></div>
<map name="QCA_1_1SyncThread_coll__map" id="QCA_1_1SyncThread_coll__map">
<area shape="rect" doxygen="qt.tag:" href="qthread.html" title="QThread" alt="" coords="5,5,75,35"/></map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>

<p><a href="classQCA_1_1SyncThread-members.html">List of all members.</a></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="elRef" doxygen="qt.tag:" href="qvariant.html">QVariant</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQCA_1_1SyncThread.html#a50df14a38deac80c42f17c3e968e52bb">call</a> (<a class="elRef" doxygen="qt.tag:" href="qobject.html">QObject</a> *obj, const <a class="elRef" doxygen="qt.tag:" href="qbytearray.html">QByteArray</a> &amp;method, const QVariantList &amp;args=QVariantList(), bool *ok=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQCA_1_1SyncThread.html#af2ad952e1f3e10173e467b52791baeee">start</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQCA_1_1SyncThread.html#a77113f4ec74348dc41263568509f4e38">stop</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQCA_1_1SyncThread.html#a2b4f99a230cd531f61c1c7e594378748">SyncThread</a> (<a class="elRef" doxygen="qt.tag:" href="qobject.html">QObject</a> *parent=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQCA_1_1SyncThread.html#a02de52337dce055bf62af4ff0b9da867">~SyncThread</a> ()</td></tr>
<tr><td colspan="2"><h2>Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQCA_1_1SyncThread.html#acddee6d75a49c66bc4420cb565e5b896">atEnd</a> ()=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQCA_1_1SyncThread.html#a0e5de741e3c0e2056469fd77849b7abd">atStart</a> ()=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQCA_1_1SyncThread.html#a3432c746333edded144a5d43576d1012">run</a> ()</td></tr>
<tr><td colspan="2"><h2>Friends</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac96b60d37bd806132da680e187dc2288"></a><!-- doxytag: member="QCA::SyncThread::Private" ref="ac96b60d37bd806132da680e187dc2288" args="" -->
class&nbsp;</td><td class="memItemRight" valign="bottom"><b>Private</b></td></tr>
<tr><td colspan="2"><h2>Related Functions</h2></td></tr>
<tr><td colspan="2"><p>(Note that these are not member functions.) </p>
<br/><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">QCA_EXPORT bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQCA_1_1SyncThread.html#a0493eb0b640e8d3a275d26c6706a1a6e">invokeMethodWithVariants</a> (<a class="elRef" doxygen="qt.tag:" href="qobject.html">QObject</a> *obj, const <a class="elRef" doxygen="qt.tag:" href="qbytearray.html">QByteArray</a> &amp;method, const QVariantList &amp;args, <a class="elRef" doxygen="qt.tag:" href="qvariant.html">QVariant</a> *ret, Qt::ConnectionType type=Qt::AutoConnection)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">QCA_EXPORT <a class="elRef" doxygen="qt.tag:" href="qbytearray.html">QByteArray</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQCA_1_1SyncThread.html#a489c4d656b533b3e0f033d5c035421d7">methodReturnType</a> (const <a class="elRef" doxygen="qt.tag:" href="qmetaobject.html">QMetaObject</a> *obj, const <a class="elRef" doxygen="qt.tag:" href="qbytearray.html">QByteArray</a> &amp;method, const <a class="elRef" doxygen="qt.tag:" href="qlist.html">QList</a>&lt; <a class="elRef" doxygen="qt.tag:" href="qbytearray.html">QByteArray</a> &gt; argTypes)</td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>Convenience class to run a thread and interact with it synchronously. </p>
<p><a class="el" href="classQCA_1_1SyncThread.html" title="Convenience class to run a thread and interact with it synchronously.">SyncThread</a> makes it easy to perform the common practice of starting a thread, running some objects in that thread, and then interacting with those objects safely. Often, there is no need to directly use threading primitives (e.g. <a class="elRef" doxygen="qt.tag:" href="qmutex.html">QMutex</a>), resulting in very clean multi-threaded code.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>The following is an excerpt from <a href="http://delta.affinix.com/2006/11/13/synchronized-threads-part-3/">http://delta.affinix.com/2006/11/13/synchronized-threads-part-3/</a></dd></dl>
<p>---<br/>
 With <a class="el" href="classQCA_1_1SyncThread.html" title="Convenience class to run a thread and interact with it synchronously.">SyncThread</a>, you can start, stop, and call a method in another thread while the main thread sleeps. The only requirement is that the methods be declared as slots.</p>
<p>Below is a contrived example, where we have an object in another thread that increments a counter over a some interval, using the Qt event loop, and provides a method to inspect the value.</p>
<p>First, the Counter object:</p>
<div class="fragment"><pre class="fragment"><span class="keyword">class </span>Counter : <span class="keyword">public</span> <a class="codeRef" doxygen="qt.tag:" href="qobject.html">QObject</a>
{
        Q_OBJECT
<span class="keyword">private</span>:
        <span class="keywordtype">int</span> x;
        <a class="codeRef" doxygen="qt.tag:" href="qtimer.html">QTimer</a> timer;

<span class="keyword">public</span>:
        Counter() : timer(this)
        {
                x = 0;
                connect(&amp;timer, SIGNAL(timeout()), SLOT(t_timeout()));
        }

<span class="keyword">public</span> slots:
        <span class="keywordtype">void</span> <a class="code" href="classQCA_1_1SyncThread.html#af2ad952e1f3e10173e467b52791baeee" title="Starts the thread, begins the event loop the thread, and then calls atStart() in...">start</a>(<span class="keywordtype">int</span> seconds)
        {
                timer.setInterval(seconds * 1000);
                timer.start();
        }

        <span class="keywordtype">int</span> value()<span class="keyword"> const</span>
<span class="keyword">        </span>{
                <span class="keywordflow">return</span> x;
        }

<span class="keyword">private</span> slots:
        <span class="keywordtype">void</span> t_timeout()
        {
                ++x;
        }
};
</pre></div><p>Looks like a typical object, no surprises.</p>
<p>Now to wrap Counter with <a class="el" href="classQCA_1_1SyncThread.html" title="Convenience class to run a thread and interact with it synchronously.">SyncThread</a>. We went over how to do this in the first article, and it is very straightforward:</p>
<div class="fragment"><pre class="fragment"><span class="keyword">class </span>CounterThread : <span class="keyword">public</span> <a class="code" href="classQCA_1_1SyncThread.html#a2b4f99a230cd531f61c1c7e594378748" title="Standard constructor.">SyncThread</a>
{
        Q_OBJECT
<span class="keyword">public</span>:
        Counter *counter;

        CounterThread(<a class="codeRef" doxygen="qt.tag:" href="qobject.html">QObject</a> *parent) : <a class="code" href="classQCA_1_1SyncThread.html#a2b4f99a230cd531f61c1c7e594378748" title="Standard constructor.">SyncThread</a>(parent)
        {
                counter = 0;
        }

        ~CounterThread()
        {
                <span class="comment">// SyncThread will stop the thread on destruct, but since our</span>
                <span class="comment">//   atStop() function makes references to CounterThread&#39;s</span>
                <span class="comment">//   members, we need to shutdown here, before CounterThread</span>
                <span class="comment">//   destructs.</span>
                <a class="code" href="classQCA_1_1SyncThread.html#a77113f4ec74348dc41263568509f4e38" title="Stops the event loop of the thread, calls atStop() in the thread, and instructs the...">stop</a>();
        }

<span class="keyword">protected</span>:
        <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="classQCA_1_1SyncThread.html#a0e5de741e3c0e2056469fd77849b7abd" title="Reimplement this to perform your initialization.">atStart</a>()
        {
                counter = <span class="keyword">new</span> Counter;
        }

        <span class="keyword">virtual</span> <span class="keywordtype">void</span> atStop()
        {
                <span class="keyword">delete</span> counter;
        }
};
</pre></div><p>We can then use it like this:</p>
<div class="fragment"><pre class="fragment">CounterThread *thread = <span class="keyword">new</span> CounterThread;

<span class="comment">// after this call, the thread is started and the Counter is ready</span>
thread-&gt;start();

<span class="comment">// let&#39;s start the counter with a 1 second interval</span>
thread-&gt;call(thread-&gt;counter, <span class="stringliteral">&quot;start&quot;</span>, QVariantList() &lt;&lt; 1);
...

<span class="comment">// after some time passes, let&#39;s check on the value</span>
int x = thread-&gt;call(thread-&gt;counter, <span class="stringliteral">&quot;value&quot;</span>).toInt();

<span class="comment">// we&#39;re done with this thing</span>
<span class="keyword">delete</span> thread;
</pre></div><p>Do you see a mutex anywhere? I didn't think so.<br/>
 ---</p>
<p>Even without the <a class="el" href="classQCA_1_1SyncThread.html#a50df14a38deac80c42f17c3e968e52bb" title="Calls a slot of an object in the thread.">call()</a> function, <a class="el" href="classQCA_1_1SyncThread.html" title="Convenience class to run a thread and interact with it synchronously.">SyncThread</a> is still very useful for preparing objects in another thread, which you can then <a class="elRef" doxygen="qt.tag:" href="qobject.html#connect">QObject::connect()</a> to and use signals and slots like normal. </p>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a2b4f99a230cd531f61c1c7e594378748"></a><!-- doxytag: member="QCA::SyncThread::SyncThread" ref="a2b4f99a230cd531f61c1c7e594378748" args="(QObject *parent=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">QCA::SyncThread::SyncThread </td>
          <td>(</td>
          <td class="paramtype"><a class="elRef" doxygen="qt.tag:" href="qobject.html">QObject</a> *&nbsp;</td>
          <td class="paramname"> <em>parent</em> = <code>0</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Standard constructor. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>parent</em>&nbsp;</td><td>the parent object for this parent. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a02de52337dce055bf62af4ff0b9da867"></a><!-- doxytag: member="QCA::SyncThread::~SyncThread" ref="a02de52337dce055bf62af4ff0b9da867" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">QCA::SyncThread::~SyncThread </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Calls <a class="el" href="classQCA_1_1SyncThread.html#a77113f4ec74348dc41263568509f4e38" title="Stops the event loop of the thread, calls atStop() in the thread, and instructs the...">stop()</a> and then destructs. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>Subclasses should call <a class="el" href="classQCA_1_1SyncThread.html#a77113f4ec74348dc41263568509f4e38" title="Stops the event loop of the thread, calls atStop() in the thread, and instructs the...">stop()</a> in their own destructor </dd></dl>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="af2ad952e1f3e10173e467b52791baeee"></a><!-- doxytag: member="QCA::SyncThread::start" ref="af2ad952e1f3e10173e467b52791baeee" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void QCA::SyncThread::start </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Starts the thread, begins the event loop the thread, and then calls <a class="el" href="classQCA_1_1SyncThread.html#a0e5de741e3c0e2056469fd77849b7abd" title="Reimplement this to perform your initialization.">atStart()</a> in the thread. </p>
<p>This function will block until <a class="el" href="classQCA_1_1SyncThread.html#a0e5de741e3c0e2056469fd77849b7abd" title="Reimplement this to perform your initialization.">atStart()</a> has returned. </p>

</div>
</div>
<a class="anchor" id="a77113f4ec74348dc41263568509f4e38"></a><!-- doxytag: member="QCA::SyncThread::stop" ref="a77113f4ec74348dc41263568509f4e38" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void QCA::SyncThread::stop </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Stops the event loop of the thread, calls atStop() in the thread, and instructs the thread to finish. </p>
<p>This function will block until the thread has finished. </p>

</div>
</div>
<a class="anchor" id="a50df14a38deac80c42f17c3e968e52bb"></a><!-- doxytag: member="QCA::SyncThread::call" ref="a50df14a38deac80c42f17c3e968e52bb" args="(QObject *obj, const QByteArray &amp;method, const QVariantList &amp;args=QVariantList(), bool *ok=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" doxygen="qt.tag:" href="qvariant.html">QVariant</a> QCA::SyncThread::call </td>
          <td>(</td>
          <td class="paramtype"><a class="elRef" doxygen="qt.tag:" href="qobject.html">QObject</a> *&nbsp;</td>
          <td class="paramname"> <em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" doxygen="qt.tag:" href="qbytearray.html">QByteArray</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>method</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const QVariantList &amp;&nbsp;</td>
          <td class="paramname"> <em>args</em> = <code>QVariantList()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&nbsp;</td>
          <td class="paramname"> <em>ok</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Calls a slot of an object in the thread. </p>
<p>This function will block until the slot has returned.</p>
<p>It is possible for the call to fail, for example if the method does not exist.</p>
<p>The arguments and return value of the call use <a class="elRef" doxygen="qt.tag:" href="qvariant.html">QVariant</a>. If the method has no return value (returns void), then the returned <a class="elRef" doxygen="qt.tag:" href="qvariant.html">QVariant</a> will be null.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>obj</em>&nbsp;</td><td>the object to call the method on </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>method</em>&nbsp;</td><td>the name of the method (without the arguments or brackets) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>args</em>&nbsp;</td><td>the list of arguments to use in the method call </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ok</em>&nbsp;</td><td>if not 0, true is stored here if the call succeeds, otherwise false is stored here. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0e5de741e3c0e2056469fd77849b7abd"></a><!-- doxytag: member="QCA::SyncThread::atStart" ref="a0e5de741e3c0e2056469fd77849b7abd" args="()=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void QCA::SyncThread::atStart </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [protected, pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reimplement this to perform your initialization. </p>

</div>
</div>
<a class="anchor" id="acddee6d75a49c66bc4420cb565e5b896"></a><!-- doxytag: member="QCA::SyncThread::atEnd" ref="acddee6d75a49c66bc4420cb565e5b896" args="()=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void QCA::SyncThread::atEnd </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [protected, pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reimplement this to perform your deinitialization. </p>

</div>
</div>
<a class="anchor" id="a3432c746333edded144a5d43576d1012"></a><!-- doxytag: member="QCA::SyncThread::run" ref="a3432c746333edded144a5d43576d1012" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void QCA::SyncThread::run </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Starts the event loop and calls atStart and atStop as necessary. </p>

<p>Reimplemented from <a class="elRef" doxygen="qt.tag:" href="qthread.html#run">QThread</a>.</p>

</div>
</div>
<hr/><h2>Friends And Related Function Documentation</h2>
<a class="anchor" id="a489c4d656b533b3e0f033d5c035421d7"></a><!-- doxytag: member="QCA::SyncThread::methodReturnType" ref="a489c4d656b533b3e0f033d5c035421d7" args="(const QMetaObject *obj, const QByteArray &amp;method, const QList&lt; QByteArray &gt; argTypes)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">QCA_EXPORT <a class="elRef" doxygen="qt.tag:" href="qbytearray.html">QByteArray</a> methodReturnType </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" doxygen="qt.tag:" href="qmetaobject.html">QMetaObject</a> *&nbsp;</td>
          <td class="paramname"> <em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" doxygen="qt.tag:" href="qbytearray.html">QByteArray</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>method</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" doxygen="qt.tag:" href="qlist.html">QList</a>&lt; <a class="elRef" doxygen="qt.tag:" href="qbytearray.html">QByteArray</a> &gt;&nbsp;</td>
          <td class="paramname"> <em>argTypes</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [related]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Convenience method to determine the return type of a method. </p>
<p>This function identifies the return type of a specified method. This function can be used as shown: </p>
<div class="fragment"><pre class="fragment"><span class="keyword">class </span>TestClass : <span class="keyword">public</span> <a class="codeRef" doxygen="qt.tag:" href="qobject.html">QObject</a>
{
    Q_OBJECT
    <span class="comment">// ...</span>
<span class="keyword">public</span> slots:
    <a class="codeRef" doxygen="qt.tag:" href="qstring.html">QString</a> qstringMethod()  { <span class="keywordflow">return</span> <a class="codeRef" doxygen="qt.tag:" href="qstring.html">QString</a>(); };
    <span class="keywordtype">bool</span> boolMethod( <span class="keyword">const</span> <a class="codeRef" doxygen="qt.tag:" href="qstring.html">QString</a> &amp; )  { <span class="keywordflow">return</span> <span class="keyword">true</span>; };
};

<a class="codeRef" doxygen="qt.tag:" href="qbytearray.html">QByteArray</a> myTypeName;

TestClass testClass;
<a class="codeRef" doxygen="qt.tag:" href="qlist.html">QList&lt;QByteArray&gt;</a> argsList; <span class="comment">// empty list, since no args</span>

myTypeName = <a class="code" href="classQCA_1_1SyncThread.html#a489c4d656b533b3e0f033d5c035421d7" title="Convenience method to determine the return type of a method.">QCA::methodReturnType</a>( testClass.metaObject(), <a class="codeRef" doxygen="qt.tag:" href="qbytearray.html">QByteArray</a>( <span class="stringliteral">&quot;qstringMethod&quot;</span> ), argsList );
<span class="comment">// myTypeName is &quot;QString&quot;</span>

myTypeName = <a class="code" href="classQCA_1_1SyncThread.html#a489c4d656b533b3e0f033d5c035421d7" title="Convenience method to determine the return type of a method.">QCA::methodReturnType</a>( testClass.metaObject(), <a class="codeRef" doxygen="qt.tag:" href="qbytearray.html">QByteArray</a>( <span class="stringliteral">&quot;boolMethod&quot;</span> ), argsList );
<span class="comment">// myTypeName is &quot;&quot;, because there is no method called &quot;boolMethod&quot; that has no arguments</span>

argsList &lt;&lt; <span class="stringliteral">&quot;QString&quot;</span>; <span class="comment">// now we have one argument</span>
myTypeName = <a class="code" href="classQCA_1_1SyncThread.html#a489c4d656b533b3e0f033d5c035421d7" title="Convenience method to determine the return type of a method.">QCA::methodReturnType</a>( testClass.metaObject(), <a class="codeRef" doxygen="qt.tag:" href="qbytearray.html">QByteArray</a>( <span class="stringliteral">&quot;boolMethod&quot;</span> ), argsList );
<span class="comment">// myTypeName is &quot;bool&quot;</span>
</pre></div><p>The return type name of a method returning void is an empty string, not "void"</p>
<dl class="note"><dt><b>Note:</b></dt><dd>This function is not normally required for use with QCA. It is provided for use in your code, if required.</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>obj</em>&nbsp;</td><td>the <a class="elRef" doxygen="qt.tag:" href="qmetaobject.html">QMetaObject</a> for the object </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>method</em>&nbsp;</td><td>the name of the method (without the arguments or brackets) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>argTypes</em>&nbsp;</td><td>the list of argument types of the method</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the name of the type that this method will return with the specified argument types.</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="elRef" doxygen="qt.tag:" href="qmetatype.html">QMetaType</a> for more information on the Qt meta type system. </dd></dl>

</div>
</div>
<a class="anchor" id="a0493eb0b640e8d3a275d26c6706a1a6e"></a><!-- doxytag: member="QCA::SyncThread::invokeMethodWithVariants" ref="a0493eb0b640e8d3a275d26c6706a1a6e" args="(QObject *obj, const QByteArray &amp;method, const QVariantList &amp;args, QVariant *ret, Qt::ConnectionType type=Qt::AutoConnection)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">QCA_EXPORT bool invokeMethodWithVariants </td>
          <td>(</td>
          <td class="paramtype"><a class="elRef" doxygen="qt.tag:" href="qobject.html">QObject</a> *&nbsp;</td>
          <td class="paramname"> <em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" doxygen="qt.tag:" href="qbytearray.html">QByteArray</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>method</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const QVariantList &amp;&nbsp;</td>
          <td class="paramname"> <em>args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="elRef" doxygen="qt.tag:" href="qvariant.html">QVariant</a> *&nbsp;</td>
          <td class="paramname"> <em>ret</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Qt::ConnectionType&nbsp;</td>
          <td class="paramname"> <em>type</em> = <code>Qt::AutoConnection</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [related]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Convenience method to invoke a method by name, using a variant list of arguments. </p>
<p>This function can be used as shown: </p>
<div class="fragment"><pre class="fragment"><span class="keyword">class </span>TestClass : <span class="keyword">public</span> <a class="codeRef" doxygen="qt.tag:" href="qobject.html">QObject</a>
{
    Q_OBJECT
    <span class="comment">// ...</span>
<span class="keyword">public</span> slots:
    <a class="codeRef" doxygen="qt.tag:" href="qstring.html">QString</a> qstringMethod()  { <span class="keywordflow">return</span> <a class="codeRef" doxygen="qt.tag:" href="qstring.html">QString</a>( <span class="stringliteral">&quot;the result&quot;</span> ); };
    <span class="keywordtype">bool</span> boolMethod( <span class="keyword">const</span> <a class="codeRef" doxygen="qt.tag:" href="qstring.html">QString</a> &amp; )  { <span class="keywordflow">return</span> <span class="keyword">true</span>; };
};

TestClass *testClass = <span class="keyword">new</span> TestClass;
QVariantList args;

<a class="codeRef" doxygen="qt.tag:" href="qvariant.html">QVariant</a> stringRes;
<span class="comment">// calls testClass-&gt;qstringMethod() with no arguments ( since args is an empty list)</span>
<span class="keywordtype">bool</span> ret = <a class="code" href="classQCA_1_1SyncThread.html#a0493eb0b640e8d3a275d26c6706a1a6e" title="Convenience method to invoke a method by name, using a variant list of arguments...">QCA::invokeMethodWithVariants</a>( testClass, <a class="codeRef" doxygen="qt.tag:" href="qbytearray.html">QByteArray</a>( <span class="stringliteral">&quot;qstringMethod&quot;</span> ), args, &amp;stringRes );
<span class="comment">// ret is true (since call succeeded), stringRes.toString() is a string - &quot;the result&quot;</span>

<a class="codeRef" doxygen="qt.tag:" href="qvariant.html">QVariant</a> boolResult;
<a class="codeRef" doxygen="qt.tag:" href="qstring.html">QString</a> someString( <span class="stringliteral">&quot;not important&quot;</span> );
args &lt;&lt; someString;
<span class="comment">// calls testClass-&gt;boolMethod( someString ), returning result in boolResult</span>
ret = <a class="code" href="classQCA_1_1SyncThread.html#a0493eb0b640e8d3a275d26c6706a1a6e" title="Convenience method to invoke a method by name, using a variant list of arguments...">QCA::invokeMethodWithVariants</a>( testClass1, <a class="codeRef" doxygen="qt.tag:" href="qbytearray.html">QByteArray</a>( <span class="stringliteral">&quot;boolMethod&quot;</span> ), args, &amp;boolResult );
<span class="comment">// ret is true (since call succeeded), boolResult.toBool() is true.</span>
</pre></div><dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>obj</em>&nbsp;</td><td>the object to call the method on </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>method</em>&nbsp;</td><td>the name of the method (without the arguments or brackets) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>args</em>&nbsp;</td><td>the list of arguments to use in the method call </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ret</em>&nbsp;</td><td>the return value of the method (unchanged if the call fails) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>type</em>&nbsp;</td><td>the type of connection to use</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if the call succeeded, otherwise false </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="qca__support_8h_source.html">qca_support.h</a></li>
</ul>
</div>
<hr class="footer"/><address style="text-align: right;"><small>Generated on Sat Nov 27 13:41:19 2010 for Qt Cryptographic Architecture by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.3 </small></address>
</body>
</html>
