<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Qt Cryptographic Architecture: QCA::Hash Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.3 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath"><a class="el" href="namespaceQCA.html">QCA</a>::<a class="el" href="classQCA_1_1Hash.html">Hash</a>
  </div>
</div>
<div class="contents">
<h1>QCA::Hash Class Reference<br/>
<small>
[<a class="el" href="group__UserAPI.html">QCA user API</a>]</small>
</h1><!-- doxytag: class="QCA::Hash" --><!-- doxytag: inherits="QCA::Algorithm,QCA::BufferedComputation" -->
<p>General class for hashing algorithms.  
<a href="#_details">More...</a></p>

<p><code>#include &lt;<a class="el" href="qca__basic_8h_source.html">QtCrypto</a>&gt;</code></p>
<div class="dynheader">
Collaboration diagram for QCA::Hash:</div>
<div class="dynsection">
<div class="center"><img src="classQCA_1_1Hash__coll__graph.png" border="0" usemap="#QCA_1_1Hash_coll__map" alt="Collaboration graph"/></div>
<map name="QCA_1_1Hash_coll__map" id="QCA_1_1Hash_coll__map">
<area shape="rect" href="classQCA_1_1Algorithm.html" title="General superclass for an algorithm." alt="" coords="51,101,163,131"/><area shape="rect" doxygen="qt.tag:" href="qshareddatapointer.html" title="QSharedDataPointer\&lt; Private \&gt;" alt="" coords="5,5,208,35"/><area shape="rect" href="classQCA_1_1BufferedComputation.html" title="General superclass for buffered computation algorithms." alt="" coords="187,101,365,131"/></map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>

<p><a href="classQCA_1_1Hash-members.html">List of all members.</a></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQCA_1_1Hash.html#aad9e4eb96f7c5fd93f1cd8b3092755de">clear</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classQCA_1_1MemoryRegion.html">MemoryRegion</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQCA_1_1Hash.html#a9b1e200b130e7631dc284f89046e891f">final</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classQCA_1_1MemoryRegion.html">MemoryRegion</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQCA_1_1Hash.html#a2fdc0801da1cd143c3f345f6da436e21">hash</a> (const <a class="el" href="classQCA_1_1MemoryRegion.html">MemoryRegion</a> &amp;array)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQCA_1_1Hash.html#ac239966e6034c675b9162d9d2502cbc3">Hash</a> (const <a class="el" href="classQCA_1_1Hash.html">Hash</a> &amp;from)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQCA_1_1Hash.html#adf55eca875d0934e152922872ed84aa5">Hash</a> (const <a class="elRef" doxygen="qt.tag:" href="qstring.html">QString</a> &amp;type, const <a class="elRef" doxygen="qt.tag:" href="qstring.html">QString</a> &amp;provider=<a class="elRef" doxygen="qt.tag:" href="qstring.html">QString</a>())</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="elRef" doxygen="qt.tag:" href="qstring.html">QString</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQCA_1_1Hash.html#ac6fde189a4a12f404165a28ba0a558bd">hashToString</a> (const <a class="el" href="classQCA_1_1MemoryRegion.html">MemoryRegion</a> &amp;array)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classQCA_1_1Hash.html">Hash</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQCA_1_1Hash.html#a36165de11895663fb1c6ea5625d3e418">operator=</a> (const <a class="el" href="classQCA_1_1Hash.html">Hash</a> &amp;from)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="elRef" doxygen="qt.tag:" href="qstring.html">QString</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQCA_1_1Hash.html#a392b0ace85c55bd90dc0ab56a159bf95">type</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQCA_1_1Hash.html#a122785186f0b57f4782694ffde5b647f">update</a> (<a class="elRef" doxygen="qt.tag:" href="qiodevice.html">QIODevice</a> *file)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQCA_1_1Hash.html#aec7e82484e020519539fde61d6e907de">update</a> (const char *data, int len=-1)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQCA_1_1Hash.html#a77fcb4fc72f9059d57e35f33dd21b136">update</a> (const <a class="elRef" doxygen="qt.tag:" href="qbytearray.html">QByteArray</a> &amp;a)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQCA_1_1Hash.html#a91efd04d2a310e75b6a8f1baffa86f9f">update</a> (const <a class="el" href="classQCA_1_1MemoryRegion.html">MemoryRegion</a> &amp;a)</td></tr>
<tr><td colspan="2"><h2>Static Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="elRef" doxygen="qt.tag:" href="qstringlist.html">QStringList</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQCA_1_1Hash.html#a10ca797896ccd51236c1afc89de1cb44">supportedTypes</a> (const <a class="elRef" doxygen="qt.tag:" href="qstring.html">QString</a> &amp;provider=<a class="elRef" doxygen="qt.tag:" href="qstring.html">QString</a>())</td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>General class for hashing algorithms. </p>
<p><a class="el" href="classQCA_1_1Hash.html" title="General class for hashing algorithms.">Hash</a> is the class for the various hashing algorithms within QCA. SHA256, SHA1 or RIPEMD160 are recommended for new applications, although MD2, MD4, MD5 or SHA0 may be applicable (for interoperability reasons) for some applications.</p>
<p>To perform a hash, you create a <a class="el" href="classQCA_1_1Hash.html" title="General class for hashing algorithms.">Hash</a> object, call <a class="el" href="classQCA_1_1Hash.html#a91efd04d2a310e75b6a8f1baffa86f9f" title="Update a hash, adding more of the message contents to the digest.">update()</a> with the data that needs to be hashed, and then call <a class="el" href="classQCA_1_1Hash.html#a9b1e200b130e7631dc284f89046e891f" title="Finalises input and returns the hash result.">final()</a>, which returns a <a class="elRef" doxygen="qt.tag:" href="qbytearray.html">QByteArray</a> of the hash result. An example (using the SHA1 hash, with 1000 updates of a 1000 byte string) is shown below:</p>
<div class="fragment"><pre class="fragment"><span class="keywordflow">if</span>(!<a class="code" href="namespaceQCA.html#a833c9f215544113d52a3a52eedc58620" title="Test if a capability (algorithm) is available.">QCA::isSupported</a>(<span class="stringliteral">&quot;sha1&quot;</span>))
        printf(<span class="stringliteral">&quot;SHA1 not supported!\n&quot;</span>);
<span class="keywordflow">else</span>
{
        <a class="codeRef" doxygen="qt.tag:" href="qbytearray.html">QByteArray</a> fillerString;
        fillerString.<a class="codeRef" doxygen="qt.tag:" href="qbytearray.html#fill">fill</a>(<span class="charliteral">&#39;a&#39;</span>, 1000);

        <a class="code" href="classQCA_1_1Hash.html" title="General class for hashing algorithms.">QCA::Hash</a> shaHash(<span class="stringliteral">&quot;sha1&quot;</span>);
        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;1000; i++)
                shaHash.update(fillerString);
        <a class="codeRef" doxygen="qt.tag:" href="qbytearray.html">QByteArray</a> hashResult = shaHash.final();
        <span class="keywordflow">if</span> ( <span class="stringliteral">&quot;34aa973cd4c4daa4f61eeb2bdbad27316534016f&quot;</span> == <a class="code" href="namespaceQCA.html#a5df0264a9d1b8fa52a7bce4aaa49ad4c" title="Convert a byte array to printable hexadecimal representation.">QCA::arrayToHex</a>(hashResult) )
        {
                printf(<span class="stringliteral">&quot;big SHA1 is OK\n&quot;</span>);
        }
        <span class="keywordflow">else</span>
        {
                printf(<span class="stringliteral">&quot;big SHA1 failed\n&quot;</span>);
        }
}
</pre></div><p>If you only have a simple hash requirement - a single string that is fully available in memory at one time - then you may be better off with one of the convenience methods. So, for example, instead of creating a <a class="el" href="classQCA_1_1Hash.html" title="General class for hashing algorithms.">QCA::Hash</a> object, then doing a single <a class="el" href="classQCA_1_1Hash.html#a91efd04d2a310e75b6a8f1baffa86f9f" title="Update a hash, adding more of the message contents to the digest.">update()</a> and the <a class="el" href="classQCA_1_1Hash.html#a9b1e200b130e7631dc284f89046e891f" title="Finalises input and returns the hash result.">final()</a> call; you could simply call <a class="el" href="classQCA_1_1Hash.html" title="General class for hashing algorithms.">QCA::Hash</a>("algoName").<a class="el" href="classQCA_1_1Hash.html#a2fdc0801da1cd143c3f345f6da436e21" title="Hash a byte array, returning it as another byte array">hash()</a> with the data that you would otherwise have provided to the <a class="el" href="classQCA_1_1Hash.html#a91efd04d2a310e75b6a8f1baffa86f9f" title="Update a hash, adding more of the message contents to the digest.">update()</a> call.</p>
<p>For more information on hashing algorithms, see <a class="el" href="hashing.html">Hashing Algorithms</a>. </p>
<dl><dt><b>Examples: </b></dt><dd>
<p><a class="el" href="hashtest_8cpp-example.html#_a6">hashtest.cpp</a>, and <a class="el" href="md5crypt_8cpp-example.html#_a4">md5crypt.cpp</a>.</p>
</dd>
</dl><hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="adf55eca875d0934e152922872ed84aa5"></a><!-- doxytag: member="QCA::Hash::Hash" ref="adf55eca875d0934e152922872ed84aa5" args="(const QString &amp;type, const QString &amp;provider=QString())" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">QCA::Hash::Hash </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" doxygen="qt.tag:" href="qstring.html">QString</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" doxygen="qt.tag:" href="qstring.html">QString</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>provider</em> = <code><a class="elRef" doxygen="qt.tag:" href="qstring.html">QString</a>()</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Constructor. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>type</em>&nbsp;</td><td>label for the type of hash to be created (for example, "sha1" or "md2") </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>provider</em>&nbsp;</td><td>the name of the provider plugin for the subclass (eg "qca-ossl") </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac239966e6034c675b9162d9d2502cbc3"></a><!-- doxytag: member="QCA::Hash::Hash" ref="ac239966e6034c675b9162d9d2502cbc3" args="(const Hash &amp;from)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">QCA::Hash::Hash </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classQCA_1_1Hash.html">Hash</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>from</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Copy constructor. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>from</em>&nbsp;</td><td>the <a class="el" href="classQCA_1_1Hash.html" title="General class for hashing algorithms.">Hash</a> object to copy from </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a36165de11895663fb1c6ea5625d3e418"></a><!-- doxytag: member="QCA::Hash::operator=" ref="a36165de11895663fb1c6ea5625d3e418" args="(const Hash &amp;from)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classQCA_1_1Hash.html">Hash</a>&amp; QCA::Hash::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classQCA_1_1Hash.html">Hash</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>from</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Assignment operator. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>from</em>&nbsp;</td><td>the <a class="el" href="classQCA_1_1Hash.html" title="General class for hashing algorithms.">Hash</a> object to copy state from </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a10ca797896ccd51236c1afc89de1cb44"></a><!-- doxytag: member="QCA::Hash::supportedTypes" ref="a10ca797896ccd51236c1afc89de1cb44" args="(const QString &amp;provider=QString())" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="elRef" doxygen="qt.tag:" href="qstringlist.html">QStringList</a> QCA::Hash::supportedTypes </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" doxygen="qt.tag:" href="qstring.html">QString</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>provider</em> = <code><a class="elRef" doxygen="qt.tag:" href="qstring.html">QString</a>()</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns a list of all of the hash types available. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>provider</em>&nbsp;</td><td>the name of the provider to get a list from, if one provider is required. If not specified, available hash types from all providers will be returned. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a392b0ace85c55bd90dc0ab56a159bf95"></a><!-- doxytag: member="QCA::Hash::type" ref="a392b0ace85c55bd90dc0ab56a159bf95" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" doxygen="qt.tag:" href="qstring.html">QString</a> QCA::Hash::type </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return the hash type. </p>

<p>Reimplemented from <a class="el" href="classQCA_1_1Algorithm.html#a503255bf0a33bad64c2d2aedc361e4c7">QCA::Algorithm</a>.</p>

</div>
</div>
<a class="anchor" id="aad9e4eb96f7c5fd93f1cd8b3092755de"></a><!-- doxytag: member="QCA::Hash::clear" ref="aad9e4eb96f7c5fd93f1cd8b3092755de" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void QCA::Hash::clear </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reset a hash, dumping all previous parts of the message. </p>
<p>This method clears (or resets) the hash algorithm, effectively undoing any previous <a class="el" href="classQCA_1_1Hash.html#a91efd04d2a310e75b6a8f1baffa86f9f" title="Update a hash, adding more of the message contents to the digest.">update()</a> calls. You should use this call if you are re-using a <a class="el" href="classQCA_1_1Hash.html" title="General class for hashing algorithms.">Hash</a> sub-class object to calculate additional hashes. </p>

<p>Implements <a class="el" href="classQCA_1_1BufferedComputation.html#a2e20ccb076bccedac22b36f61f7c2e29">QCA::BufferedComputation</a>.</p>

</div>
</div>
<a class="anchor" id="a91efd04d2a310e75b6a8f1baffa86f9f"></a><!-- doxytag: member="QCA::Hash::update" ref="a91efd04d2a310e75b6a8f1baffa86f9f" args="(const MemoryRegion &amp;a)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void QCA::Hash::update </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classQCA_1_1MemoryRegion.html">MemoryRegion</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>a</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Update a hash, adding more of the message contents to the digest. </p>
<p>The whole message needs to be added using this method before you call <a class="el" href="classQCA_1_1Hash.html#a9b1e200b130e7631dc284f89046e891f" title="Finalises input and returns the hash result.">final()</a>.</p>
<p>If you find yourself only calling <a class="el" href="classQCA_1_1Hash.html#a91efd04d2a310e75b6a8f1baffa86f9f" title="Update a hash, adding more of the message contents to the digest.">update()</a> once, you may be better off using a convenience method such as <a class="el" href="classQCA_1_1Hash.html#a2fdc0801da1cd143c3f345f6da436e21" title="Hash a byte array, returning it as another byte array">hash()</a> or <a class="el" href="classQCA_1_1Hash.html#ac6fde189a4a12f404165a28ba0a558bd" title="Hash a byte array, returning it as a printable string">hashToString()</a> instead.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>a</em>&nbsp;</td><td>the byte array to add to the hash </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classQCA_1_1BufferedComputation.html#a9c15b3586c1237681da2cb696e47d74f">QCA::BufferedComputation</a>.</p>

</div>
</div>
<a class="anchor" id="a77fcb4fc72f9059d57e35f33dd21b136"></a><!-- doxytag: member="QCA::Hash::update" ref="a77fcb4fc72f9059d57e35f33dd21b136" args="(const QByteArray &amp;a)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void QCA::Hash::update </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" doxygen="qt.tag:" href="qbytearray.html">QByteArray</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>a</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>a</em>&nbsp;</td><td>the <a class="elRef" doxygen="qt.tag:" href="qbytearray.html">QByteArray</a> to add to the hash </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aec7e82484e020519539fde61d6e907de"></a><!-- doxytag: member="QCA::Hash::update" ref="aec7e82484e020519539fde61d6e907de" args="(const char *data, int len=&#45;1)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void QCA::Hash::update </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>len</em> = <code>-1</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. This method is provided to assist with code that already exists, and is being ported to QCA. </p>
<p>You are better off passing a <a class="el" href="classQCA_1_1SecureArray.html" title="Secure array of bytes.">SecureArray</a> (as shown above) if you are writing new code.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>data</em>&nbsp;</td><td>pointer to a char array </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>len</em>&nbsp;</td><td>the length of the array. If not specified (or specified as a negative number), the length will be determined with strlen(), which may not be what you want if the array contains a null (0x00) character. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a122785186f0b57f4782694ffde5b647f"></a><!-- doxytag: member="QCA::Hash::update" ref="a122785186f0b57f4782694ffde5b647f" args="(QIODevice *file)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void QCA::Hash::update </td>
          <td>(</td>
          <td class="paramtype"><a class="elRef" doxygen="qt.tag:" href="qiodevice.html">QIODevice</a> *&nbsp;</td>
          <td class="paramname"> <em>file</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. This allows you to read from a file or other I/O device. </p>
<p>Note that the device must be already open for reading</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>file</em>&nbsp;</td><td>an I/O device</td></tr>
  </table>
  </dd>
</dl>
<p>If you are trying to calculate the hash of a whole file (and it isn't already open), you might want to use code like this: </p>
<div class="fragment"><pre class="fragment"><a class="codeRef" doxygen="qt.tag:" href="qfile.html">QFile</a> f( <span class="stringliteral">&quot;file.dat&quot;</span> );
<span class="keywordflow">if</span> ( f1.open( IO_ReadOnly ) )
{
        <a class="code" href="classQCA_1_1Hash.html" title="General class for hashing algorithms.">QCA::Hash</a> hashObj(<span class="stringliteral">&quot;sha1&quot;</span>);
        hashObj.update( &amp;f1 );
        <a class="codeRef" doxygen="qt.tag:" href="qstring.html">QString</a> output = hashObj.final() ) ),
}
</pre></div> 
</div>
</div>
<a class="anchor" id="a9b1e200b130e7631dc284f89046e891f"></a><!-- doxytag: member="QCA::Hash::final" ref="a9b1e200b130e7631dc284f89046e891f" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classQCA_1_1MemoryRegion.html">MemoryRegion</a> QCA::Hash::final </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Finalises input and returns the hash result. </p>
<p>After calling <a class="el" href="classQCA_1_1Hash.html#a91efd04d2a310e75b6a8f1baffa86f9f" title="Update a hash, adding more of the message contents to the digest.">update()</a> with the required data, the hash results are finalised and produced.</p>
<p>Note that it is not possible to add further data (with <a class="el" href="classQCA_1_1Hash.html#a91efd04d2a310e75b6a8f1baffa86f9f" title="Update a hash, adding more of the message contents to the digest.">update()</a>) after calling <a class="el" href="classQCA_1_1Hash.html#a9b1e200b130e7631dc284f89046e891f" title="Finalises input and returns the hash result.">final()</a>, because of the way the hashing works - null bytes are inserted to pad the results up to a fixed size. If you want to reuse the <a class="el" href="classQCA_1_1Hash.html" title="General class for hashing algorithms.">Hash</a> object, you should call <a class="el" href="classQCA_1_1Hash.html#aad9e4eb96f7c5fd93f1cd8b3092755de" title="Reset a hash, dumping all previous parts of the message.">clear()</a> and start to <a class="el" href="classQCA_1_1Hash.html#a91efd04d2a310e75b6a8f1baffa86f9f" title="Update a hash, adding more of the message contents to the digest.">update()</a> again. </p>

<p>Implements <a class="el" href="classQCA_1_1BufferedComputation.html#a6fd584099bc1c29a334afac9a809a153">QCA::BufferedComputation</a>.</p>

</div>
</div>
<a class="anchor" id="a2fdc0801da1cd143c3f345f6da436e21"></a><!-- doxytag: member="QCA::Hash::hash" ref="a2fdc0801da1cd143c3f345f6da436e21" args="(const MemoryRegion &amp;array)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classQCA_1_1MemoryRegion.html">MemoryRegion</a> QCA::Hash::hash </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classQCA_1_1MemoryRegion.html">MemoryRegion</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>array</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Hash a byte array, returning it as another byte array </p>
<p>This is a convenience method that returns the hash of a <a class="el" href="classQCA_1_1SecureArray.html" title="Secure array of bytes.">SecureArray</a>.</p>
<div class="fragment"><pre class="fragment">SecureArray sampleArray(3);
sampleArray.fill(<span class="charliteral">&#39;a&#39;</span>);
SecureArray outputArray = <a class="code" href="classQCA_1_1Hash.html#adf55eca875d0934e152922872ed84aa5" title="Constructor.">QCA::Hash</a>(<span class="stringliteral">&quot;md2&quot;</span>)::<a class="code" href="classQCA_1_1Hash.html#a2fdc0801da1cd143c3f345f6da436e21" title="Hash a byte array, returning it as another byte array">hash</a>(sampleArray);
</pre></div><dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>array</em>&nbsp;</td><td>the <a class="elRef" doxygen="qt.tag:" href="qbytearray.html">QByteArray</a> to hash</td></tr>
  </table>
  </dd>
</dl>
<p>If you need more flexibility (e.g. you are constructing a large byte array object just to pass it to <a class="el" href="classQCA_1_1Hash.html#a2fdc0801da1cd143c3f345f6da436e21" title="Hash a byte array, returning it as another byte array">hash()</a>, then consider creating an <a class="el" href="classQCA_1_1Hash.html" title="General class for hashing algorithms.">Hash</a> object, and then calling <a class="el" href="classQCA_1_1Hash.html#a91efd04d2a310e75b6a8f1baffa86f9f" title="Update a hash, adding more of the message contents to the digest.">update()</a> and <a class="el" href="classQCA_1_1Hash.html#a9b1e200b130e7631dc284f89046e891f" title="Finalises input and returns the hash result.">final()</a>. </p>

</div>
</div>
<a class="anchor" id="ac6fde189a4a12f404165a28ba0a558bd"></a><!-- doxytag: member="QCA::Hash::hashToString" ref="ac6fde189a4a12f404165a28ba0a558bd" args="(const MemoryRegion &amp;array)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" doxygen="qt.tag:" href="qstring.html">QString</a> QCA::Hash::hashToString </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classQCA_1_1MemoryRegion.html">MemoryRegion</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>array</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Hash a byte array, returning it as a printable string </p>
<p>This is a convenience method that returns the hash of a QSeecureArray as a hexadecimal representation encoded in a <a class="elRef" doxygen="qt.tag:" href="qstring.html">QString</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>array</em>&nbsp;</td><td>the <a class="elRef" doxygen="qt.tag:" href="qbytearray.html">QByteArray</a> to hash</td></tr>
  </table>
  </dd>
</dl>
<p>If you need more flexibility, you can create a <a class="el" href="classQCA_1_1Hash.html" title="General class for hashing algorithms.">Hash</a> object, call <a class="el" href="classQCA_1_1Hash.html#a91efd04d2a310e75b6a8f1baffa86f9f" title="Update a hash, adding more of the message contents to the digest.">Hash::update()</a> as required, then call <a class="el" href="classQCA_1_1Hash.html#a9b1e200b130e7631dc284f89046e891f" title="Finalises input and returns the hash result.">Hash::final()</a>, before using the static <a class="el" href="namespaceQCA.html#a5df0264a9d1b8fa52a7bce4aaa49ad4c" title="Convert a byte array to printable hexadecimal representation.">arrayToHex()</a> method. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="qca__basic_8h_source.html">qca_basic.h</a></li>
</ul>
</div>
<hr class="footer"/><address style="text-align: right;"><small>Generated on Sat Nov 27 13:41:18 2010 for Qt Cryptographic Architecture by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.3 </small></address>
</body>
</html>
