<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Qt Cryptographic Architecture: QCA::PKey Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.3 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath"><a class="el" href="namespaceQCA.html">QCA</a>::<a class="el" href="classQCA_1_1PKey.html">PKey</a>
  </div>
</div>
<div class="contents">
<h1>QCA::PKey Class Reference<br/>
<small>
[<a class="el" href="group__UserAPI.html">QCA user API</a>]</small>
</h1><!-- doxytag: class="QCA::PKey" --><!-- doxytag: inherits="QCA::Algorithm" -->
<p>General superclass for public (<a class="el" href="classQCA_1_1PublicKey.html" title="Generic public key.">PublicKey</a>) and private (<a class="el" href="classQCA_1_1PrivateKey.html" title="Generic private key.">PrivateKey</a>) keys used with asymmetric encryption techniques.  
<a href="#_details">More...</a></p>

<p><code>#include &lt;<a class="el" href="qca__publickey_8h_source.html">QtCrypto</a>&gt;</code></p>
<div class="dynheader">
Collaboration diagram for QCA::PKey:</div>
<div class="dynsection">
<div class="center"><img src="classQCA_1_1PKey__coll__graph.png" border="0" usemap="#QCA_1_1PKey_coll__map" alt="Collaboration graph"/></div>
<map name="QCA_1_1PKey_coll__map" id="QCA_1_1PKey_coll__map">
<area shape="rect" href="classQCA_1_1Algorithm.html" title="General superclass for an algorithm." alt="" coords="51,101,163,131"/><area shape="rect" doxygen="qt.tag:" href="qshareddatapointer.html" title="QSharedDataPointer\&lt; Private \&gt;" alt="" coords="5,5,208,35"/></map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>

<p><a href="classQCA_1_1PKey-members.html">List of all members.</a></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Public Types</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQCA_1_1PKey.html#aeefd3ec1b73870d1c9113c439da2839d">Type</a> { <a class="el" href="classQCA_1_1PKey.html#aeefd3ec1b73870d1c9113c439da2839da1e288411e04ef7b7b85df129e6ccff5f">RSA</a>, 
<a class="el" href="classQCA_1_1PKey.html#aeefd3ec1b73870d1c9113c439da2839da8c7a137cd5b664fd312f59844d0a0d8d">DSA</a>, 
<a class="el" href="classQCA_1_1PKey.html#aeefd3ec1b73870d1c9113c439da2839da1178d321c74a56f11d74adcddc5fa667">DH</a>
 }</td></tr>
<tr><td colspan="2"><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQCA_1_1PKey.html#aff3943249ba96bf9f6a030b18ebb52dd">bitSize</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQCA_1_1PKey.html#ac24f7143dcecade650de58872727738a">canExport</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQCA_1_1PKey.html#a734c753d1226de49e39ca4b7bfea3e73">canKeyAgree</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQCA_1_1PKey.html#a820bba0e4226c5d6c1e3bf42131d5860">isDH</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQCA_1_1PKey.html#ab0805ae5c206989b2f6acd2b75385c62">isDSA</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQCA_1_1PKey.html#a90ffbe47a89d882ba94de8c69058c954">isNull</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQCA_1_1PKey.html#a5205716d63a16cd53750a70b95ba22c8">isPrivate</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQCA_1_1PKey.html#a72274de4399c0aa03b3ad3ee7215e6ce">isPublic</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQCA_1_1PKey.html#a40a4d7d65c0284c43d696dd8fb754b56">isRSA</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQCA_1_1PKey.html#a672e0bcd6216f7547e586c704e52af3d">operator!=</a> (const <a class="el" href="classQCA_1_1PKey.html">PKey</a> &amp;a) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classQCA_1_1PKey.html">PKey</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQCA_1_1PKey.html#acc989eec603f8765d300c8bcb9e3dadf">operator=</a> (const <a class="el" href="classQCA_1_1PKey.html">PKey</a> &amp;from)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQCA_1_1PKey.html#a07e5dc66678133274752d234ec2c5f3b">operator==</a> (const <a class="el" href="classQCA_1_1PKey.html">PKey</a> &amp;a) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQCA_1_1PKey.html#a1a29ccee491baa1194d1b54355849de9">PKey</a> (const <a class="el" href="classQCA_1_1PKey.html">PKey</a> &amp;from)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQCA_1_1PKey.html#a6854f82e5ebcd191fe46173b084e88df">PKey</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classQCA_1_1PrivateKey.html">PrivateKey</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQCA_1_1PKey.html#a62d01121d3790d4d80cd4e3d60fa0ee6">toPrivateKey</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classQCA_1_1PublicKey.html">PublicKey</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQCA_1_1PKey.html#a637b51cabb26f07871bfa026a9473a14">toPublicKey</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classQCA_1_1PKey.html#aeefd3ec1b73870d1c9113c439da2839d">Type</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQCA_1_1PKey.html#a738d386df83f8555c9d0e93d4bc3b18e">type</a> () const </td></tr>
<tr><td colspan="2"><h2>Static Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="elRef" doxygen="qt.tag:" href="qlist.html">QList</a>&lt; <a class="el" href="classQCA_1_1PKey.html#aeefd3ec1b73870d1c9113c439da2839d">Type</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQCA_1_1PKey.html#ad68b59812f6f12d73e7fea736b341d8e">supportedIOTypes</a> (const <a class="elRef" doxygen="qt.tag:" href="qstring.html">QString</a> &amp;provider=<a class="elRef" doxygen="qt.tag:" href="qstring.html">QString</a>())</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="elRef" doxygen="qt.tag:" href="qlist.html">QList</a>&lt; <a class="el" href="classQCA_1_1PKey.html#aeefd3ec1b73870d1c9113c439da2839d">Type</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQCA_1_1PKey.html#a673bd71979b46610685ab9634d13c22a">supportedTypes</a> (const <a class="elRef" doxygen="qt.tag:" href="qstring.html">QString</a> &amp;provider=<a class="elRef" doxygen="qt.tag:" href="qstring.html">QString</a>())</td></tr>
<tr><td colspan="2"><h2>Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQCA_1_1PKey.html#ac8720b4a7c3236197bad5af2f38bde74">PKey</a> (const <a class="elRef" doxygen="qt.tag:" href="qstring.html">QString</a> &amp;type, const <a class="elRef" doxygen="qt.tag:" href="qstring.html">QString</a> &amp;provider)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQCA_1_1PKey.html#a085ad64e7b7f3f88adf6d814919968ab">set</a> (const <a class="el" href="classQCA_1_1PKey.html">PKey</a> &amp;k)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classQCA_1_1DHPrivateKey.html">DHPrivateKey</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQCA_1_1PKey.html#aa98d76967880530b5367609d01baf010">toDHPrivateKey</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classQCA_1_1DHPublicKey.html">DHPublicKey</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQCA_1_1PKey.html#abb07b767d8d464bc8d782f00059e4054">toDHPublicKey</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classQCA_1_1DSAPrivateKey.html">DSAPrivateKey</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQCA_1_1PKey.html#a095477c51284e49f6fbf5ed71bbabf46">toDSAPrivateKey</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classQCA_1_1DSAPublicKey.html">DSAPublicKey</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQCA_1_1PKey.html#a25e4f3431e53ccbfbbcecf379b935f32">toDSAPublicKey</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classQCA_1_1RSAPrivateKey.html">RSAPrivateKey</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQCA_1_1PKey.html#a3d723faa184b2d584ae8ff51a7ab1aaf">toRSAPrivateKey</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classQCA_1_1RSAPublicKey.html">RSAPublicKey</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQCA_1_1PKey.html#ab752131bc3a87c2970369be65b62b0bc">toRSAPublicKey</a> () const </td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>General superclass for public (<a class="el" href="classQCA_1_1PublicKey.html" title="Generic public key.">PublicKey</a>) and private (<a class="el" href="classQCA_1_1PrivateKey.html" title="Generic private key.">PrivateKey</a>) keys used with asymmetric encryption techniques. </p>
<hr/><h2>Member Enumeration Documentation</h2>
<a class="anchor" id="aeefd3ec1b73870d1c9113c439da2839d"></a><!-- doxytag: member="QCA::PKey::Type" ref="aeefd3ec1b73870d1c9113c439da2839d" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classQCA_1_1PKey.html#aeefd3ec1b73870d1c9113c439da2839d">QCA::PKey::Type</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Types of public key cryptography keys supported by <a class="el" href="namespaceQCA.html" title="QCA - the Qt Cryptographic Architecture.">QCA</a>. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="aeefd3ec1b73870d1c9113c439da2839da1e288411e04ef7b7b85df129e6ccff5f"></a><!-- doxytag: member="RSA" ref="aeefd3ec1b73870d1c9113c439da2839da1e288411e04ef7b7b85df129e6ccff5f" args="" -->RSA</em>&nbsp;</td><td>
<p>RSA key. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="aeefd3ec1b73870d1c9113c439da2839da8c7a137cd5b664fd312f59844d0a0d8d"></a><!-- doxytag: member="DSA" ref="aeefd3ec1b73870d1c9113c439da2839da8c7a137cd5b664fd312f59844d0a0d8d" args="" -->DSA</em>&nbsp;</td><td>
<p>DSA key. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="aeefd3ec1b73870d1c9113c439da2839da1178d321c74a56f11d74adcddc5fa667"></a><!-- doxytag: member="DH" ref="aeefd3ec1b73870d1c9113c439da2839da1178d321c74a56f11d74adcddc5fa667" args="" -->DH</em>&nbsp;</td><td>
<p>Diffie Hellman key. </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a6854f82e5ebcd191fe46173b084e88df"></a><!-- doxytag: member="QCA::PKey::PKey" ref="a6854f82e5ebcd191fe46173b084e88df" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">QCA::PKey::PKey </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Standard constructor. </p>

</div>
</div>
<a class="anchor" id="a1a29ccee491baa1194d1b54355849de9"></a><!-- doxytag: member="QCA::PKey::PKey" ref="a1a29ccee491baa1194d1b54355849de9" args="(const PKey &amp;from)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">QCA::PKey::PKey </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classQCA_1_1PKey.html">PKey</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>from</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Standard copy constructor. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>from</em>&nbsp;</td><td>the key to copy from </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac8720b4a7c3236197bad5af2f38bde74"></a><!-- doxytag: member="QCA::PKey::PKey" ref="ac8720b4a7c3236197bad5af2f38bde74" args="(const QString &amp;type, const QString &amp;provider)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">QCA::PKey::PKey </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" doxygen="qt.tag:" href="qstring.html">QString</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" doxygen="qt.tag:" href="qstring.html">QString</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>provider</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create a key of the specified type. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>type</em>&nbsp;</td><td>the name of the type of key to create </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>provider</em>&nbsp;</td><td>the name of the provider to create the key in </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="acc989eec603f8765d300c8bcb9e3dadf"></a><!-- doxytag: member="QCA::PKey::operator=" ref="acc989eec603f8765d300c8bcb9e3dadf" args="(const PKey &amp;from)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classQCA_1_1PKey.html">PKey</a>&amp; QCA::PKey::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classQCA_1_1PKey.html">PKey</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>from</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Standard assignment operator. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>from</em>&nbsp;</td><td>the <a class="el" href="classQCA_1_1PKey.html" title="General superclass for public (PublicKey) and private (PrivateKey) keys used with...">PKey</a> to copy from </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a673bd71979b46610685ab9634d13c22a"></a><!-- doxytag: member="QCA::PKey::supportedTypes" ref="a673bd71979b46610685ab9634d13c22a" args="(const QString &amp;provider=QString())" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="elRef" doxygen="qt.tag:" href="qlist.html">QList</a>&lt;<a class="el" href="classQCA_1_1PKey.html#aeefd3ec1b73870d1c9113c439da2839d">Type</a>&gt; QCA::PKey::supportedTypes </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" doxygen="qt.tag:" href="qstring.html">QString</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>provider</em> = <code><a class="elRef" doxygen="qt.tag:" href="qstring.html">QString</a>()</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Test what types of keys are supported. </p>
<p>Normally you would just test if the capability is present, however for <a class="el" href="classQCA_1_1PKey.html" title="General superclass for public (PublicKey) and private (PrivateKey) keys used with...">PKey</a>, you also need to test which types of keys are available. So if you want to figure out if RSA keys are supported, you need to do something like: </p>
<div class="fragment"><pre class="fragment"><span class="keywordflow">if</span>(!<a class="code" href="namespaceQCA.html#a833c9f215544113d52a3a52eedc58620" title="Test if a capability (algorithm) is available.">QCA::isSupported</a>(<span class="stringliteral">&quot;pkey&quot;</span>) ||
        !<a class="code" href="classQCA_1_1PKey.html#a673bd71979b46610685ab9634d13c22a" title="Test what types of keys are supported.">QCA::PKey::supportedTypes</a>().contains(<a class="code" href="classQCA_1_1PKey.html#aeefd3ec1b73870d1c9113c439da2839da1e288411e04ef7b7b85df129e6ccff5f" title="RSA key.">QCA::PKey::RSA</a>))
{
        <span class="comment">// then there is no RSA key support</span>
}
<span class="keywordflow">else</span>
{
        <span class="comment">// there is RSA key support</span>
}
</pre></div><p>To make things a bit more complex, <a class="el" href="classQCA_1_1PKey.html#a673bd71979b46610685ab9634d13c22a" title="Test what types of keys are supported.">supportedTypes()</a> only checks for basic functionality. If you want to check that you can do operations with PEM or DER (eg toPEM(), fromPEM(), and the equivalent DER and PEMfile operations, plus anything else that uses them, including the constructor form that takes a fileName), then you need to check for <a class="el" href="classQCA_1_1PKey.html#ad68b59812f6f12d73e7fea736b341d8e" title="Test what types of keys are supported for IO operations.">supportedIOTypes()</a> instead.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>provider</em>&nbsp;</td><td>the name of the provider to use, if a particular provider is required.</td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classQCA_1_1PKey.html#ad68b59812f6f12d73e7fea736b341d8e" title="Test what types of keys are supported for IO operations.">supportedIOTypes()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ad68b59812f6f12d73e7fea736b341d8e"></a><!-- doxytag: member="QCA::PKey::supportedIOTypes" ref="ad68b59812f6f12d73e7fea736b341d8e" args="(const QString &amp;provider=QString())" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="elRef" doxygen="qt.tag:" href="qlist.html">QList</a>&lt;<a class="el" href="classQCA_1_1PKey.html#aeefd3ec1b73870d1c9113c439da2839d">Type</a>&gt; QCA::PKey::supportedIOTypes </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" doxygen="qt.tag:" href="qstring.html">QString</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>provider</em> = <code><a class="elRef" doxygen="qt.tag:" href="qstring.html">QString</a>()</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Test what types of keys are supported for IO operations. </p>
<p>If you are using <a class="el" href="classQCA_1_1PKey.html" title="General superclass for public (PublicKey) and private (PrivateKey) keys used with...">PKey</a> DER or PEM operations, then you need to check for appropriate support using this method. For example, if you want to check if you can export or import an RSA key, then you need to do something like: </p>
<div class="fragment"><pre class="fragment"><span class="keywordflow">if</span>(!<a class="code" href="namespaceQCA.html#a833c9f215544113d52a3a52eedc58620" title="Test if a capability (algorithm) is available.">QCA::isSupported</a>(<span class="stringliteral">&quot;pkey&quot;</span>) ||
        !<a class="code" href="classQCA_1_1PKey.html#ad68b59812f6f12d73e7fea736b341d8e" title="Test what types of keys are supported for IO operations.">QCA::PKey::supportedIOTypes</a>().contains(<a class="code" href="classQCA_1_1PKey.html#aeefd3ec1b73870d1c9113c439da2839da1e288411e04ef7b7b85df129e6ccff5f" title="RSA key.">QCA::PKey::RSA</a>))
{
        <span class="comment">// then there is no RSA key IO support</span>
}
<span class="keywordflow">else</span>
{
        <span class="comment">// there is RSA key IO support</span>
}
</pre></div><p>Note that if you only want to check for basic functionality (ie not PEM or DER import/export), then you can use <a class="el" href="classQCA_1_1PKey.html#a673bd71979b46610685ab9634d13c22a" title="Test what types of keys are supported.">supportedTypes()</a>. There is no need to use both - if the key type is supported for IO, then is also supported for basic operations.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>provider</em>&nbsp;</td><td>the name of the provider to use, if a particular provider is required.</td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classQCA_1_1PKey.html#a673bd71979b46610685ab9634d13c22a" title="Test what types of keys are supported.">supportedTypes()</a> </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="rsatest_8cpp-example.html#a5">rsatest.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="a90ffbe47a89d882ba94de8c69058c954"></a><!-- doxytag: member="QCA::PKey::isNull" ref="a90ffbe47a89d882ba94de8c69058c954" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool QCA::PKey::isNull </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Test if the key is null (empty). </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if the key is null </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="rsatest_8cpp-example.html#a9">rsatest.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="a738d386df83f8555c9d0e93d4bc3b18e"></a><!-- doxytag: member="QCA::PKey::type" ref="a738d386df83f8555c9d0e93d4bc3b18e" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classQCA_1_1PKey.html#aeefd3ec1b73870d1c9113c439da2839d">Type</a> QCA::PKey::type </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Report the Type of key (eg RSA, DSA or Diffie Hellman). </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classQCA_1_1PKey.html#a40a4d7d65c0284c43d696dd8fb754b56" title="Test if the key is an RSA key.">isRSA</a>, <a class="el" href="classQCA_1_1PKey.html#ab0805ae5c206989b2f6acd2b75385c62" title="Test if the key is a DSA key.">isDSA</a> and <a class="el" href="classQCA_1_1PKey.html#a820bba0e4226c5d6c1e3bf42131d5860" title="Test if the key is a Diffie Hellman key.">isDH</a> for boolean tests. </dd></dl>

<p>Reimplemented from <a class="el" href="classQCA_1_1Algorithm.html#a503255bf0a33bad64c2d2aedc361e4c7">QCA::Algorithm</a>.</p>

</div>
</div>
<a class="anchor" id="aff3943249ba96bf9f6a030b18ebb52dd"></a><!-- doxytag: member="QCA::PKey::bitSize" ref="aff3943249ba96bf9f6a030b18ebb52dd" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int QCA::PKey::bitSize </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Report the number of bits in the key. </p>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="keyloader_8cpp-example.html#a16">keyloader.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="a40a4d7d65c0284c43d696dd8fb754b56"></a><!-- doxytag: member="QCA::PKey::isRSA" ref="a40a4d7d65c0284c43d696dd8fb754b56" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool QCA::PKey::isRSA </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Test if the key is an RSA key. </p>

</div>
</div>
<a class="anchor" id="ab0805ae5c206989b2f6acd2b75385c62"></a><!-- doxytag: member="QCA::PKey::isDSA" ref="ab0805ae5c206989b2f6acd2b75385c62" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool QCA::PKey::isDSA </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Test if the key is a DSA key. </p>

</div>
</div>
<a class="anchor" id="a820bba0e4226c5d6c1e3bf42131d5860"></a><!-- doxytag: member="QCA::PKey::isDH" ref="a820bba0e4226c5d6c1e3bf42131d5860" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool QCA::PKey::isDH </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Test if the key is a Diffie Hellman key. </p>

</div>
</div>
<a class="anchor" id="a72274de4399c0aa03b3ad3ee7215e6ce"></a><!-- doxytag: member="QCA::PKey::isPublic" ref="a72274de4399c0aa03b3ad3ee7215e6ce" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool QCA::PKey::isPublic </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Test if the key is a public key. </p>

</div>
</div>
<a class="anchor" id="a5205716d63a16cd53750a70b95ba22c8"></a><!-- doxytag: member="QCA::PKey::isPrivate" ref="a5205716d63a16cd53750a70b95ba22c8" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool QCA::PKey::isPrivate </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Test if the key is a private key. </p>

</div>
</div>
<a class="anchor" id="ac24f7143dcecade650de58872727738a"></a><!-- doxytag: member="QCA::PKey::canExport" ref="ac24f7143dcecade650de58872727738a" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool QCA::PKey::canExport </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Test if the key data can be exported. </p>
<p>If the key resides on a smart card or other such device, this will likely return false. </p>

</div>
</div>
<a class="anchor" id="a734c753d1226de49e39ca4b7bfea3e73"></a><!-- doxytag: member="QCA::PKey::canKeyAgree" ref="a734c753d1226de49e39ca4b7bfea3e73" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool QCA::PKey::canKeyAgree </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Test if the key can be used for key agreement. </p>

</div>
</div>
<a class="anchor" id="a637b51cabb26f07871bfa026a9473a14"></a><!-- doxytag: member="QCA::PKey::toPublicKey" ref="a637b51cabb26f07871bfa026a9473a14" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classQCA_1_1PublicKey.html">PublicKey</a> QCA::PKey::toPublicKey </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Interpret this key as a <a class="el" href="classQCA_1_1PublicKey.html" title="Generic public key.">PublicKey</a>. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classQCA_1_1PKey.html#ab752131bc3a87c2970369be65b62b0bc" title="Interpret this key as an RSAPublicKey.">toRSAPublicKey()</a>, <a class="el" href="classQCA_1_1PKey.html#a25e4f3431e53ccbfbbcecf379b935f32" title="Interpret this key as an DSAPublicKey.">toDSAPublicKey()</a> and <a class="el" href="classQCA_1_1PKey.html#abb07b767d8d464bc8d782f00059e4054" title="Interpret this key as an DHPublicKey.">toDHPublicKey()</a> for protected forms of this call. </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="rsatest_8cpp-example.html#a11">rsatest.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="a62d01121d3790d4d80cd4e3d60fa0ee6"></a><!-- doxytag: member="QCA::PKey::toPrivateKey" ref="a62d01121d3790d4d80cd4e3d60fa0ee6" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classQCA_1_1PrivateKey.html">PrivateKey</a> QCA::PKey::toPrivateKey </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Interpret this key as a <a class="el" href="classQCA_1_1PrivateKey.html" title="Generic private key.">PrivateKey</a>. </p>

</div>
</div>
<a class="anchor" id="a07e5dc66678133274752d234ec2c5f3b"></a><!-- doxytag: member="QCA::PKey::operator==" ref="a07e5dc66678133274752d234ec2c5f3b" args="(const PKey &amp;a) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool QCA::PKey::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classQCA_1_1PKey.html">PKey</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>a</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>test if two keys are equal </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>a</em>&nbsp;</td><td>the key to compare with this key </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a672e0bcd6216f7547e586c704e52af3d"></a><!-- doxytag: member="QCA::PKey::operator!=" ref="a672e0bcd6216f7547e586c704e52af3d" args="(const PKey &amp;a) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool QCA::PKey::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classQCA_1_1PKey.html">PKey</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>a</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>test if two keys are not equal </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>a</em>&nbsp;</td><td>the key to compare with this key </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a085ad64e7b7f3f88adf6d814919968ab"></a><!-- doxytag: member="QCA::PKey::set" ref="a085ad64e7b7f3f88adf6d814919968ab" args="(const PKey &amp;k)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void QCA::PKey::set </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classQCA_1_1PKey.html">PKey</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>k</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set the key. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>k</em>&nbsp;</td><td>the key to assign from </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab752131bc3a87c2970369be65b62b0bc"></a><!-- doxytag: member="QCA::PKey::toRSAPublicKey" ref="ab752131bc3a87c2970369be65b62b0bc" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classQCA_1_1RSAPublicKey.html">RSAPublicKey</a> QCA::PKey::toRSAPublicKey </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Interpret this key as an <a class="el" href="classQCA_1_1RSAPublicKey.html" title="RSA Public Key.">RSAPublicKey</a>. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>This function is essentially a convenience cast - if the key was created as a DSA key, this function cannot turn it into an RSA key.</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classQCA_1_1PKey.html#a637b51cabb26f07871bfa026a9473a14" title="Interpret this key as a PublicKey.">toPublicKey()</a> for the public version of this method </dd></dl>

</div>
</div>
<a class="anchor" id="a3d723faa184b2d584ae8ff51a7ab1aaf"></a><!-- doxytag: member="QCA::PKey::toRSAPrivateKey" ref="a3d723faa184b2d584ae8ff51a7ab1aaf" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classQCA_1_1RSAPrivateKey.html">RSAPrivateKey</a> QCA::PKey::toRSAPrivateKey </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Interpret this key as an <a class="el" href="classQCA_1_1RSAPrivateKey.html" title="RSA Private Key.">RSAPrivateKey</a>. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>This function is essentially a convenience cast - if the key was created as a DSA key, this function cannot turn it into a RSA key.</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classQCA_1_1PKey.html#a62d01121d3790d4d80cd4e3d60fa0ee6" title="Interpret this key as a PrivateKey.">toPrivateKey()</a> for the public version of this method </dd></dl>

</div>
</div>
<a class="anchor" id="a25e4f3431e53ccbfbbcecf379b935f32"></a><!-- doxytag: member="QCA::PKey::toDSAPublicKey" ref="a25e4f3431e53ccbfbbcecf379b935f32" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classQCA_1_1DSAPublicKey.html">DSAPublicKey</a> QCA::PKey::toDSAPublicKey </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Interpret this key as an <a class="el" href="classQCA_1_1DSAPublicKey.html" title="Digital Signature Algorithm Public Key.">DSAPublicKey</a>. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>This function is essentially a convenience cast - if the key was created as an RSA key, this function cannot turn it into a DSA key.</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classQCA_1_1PKey.html#a637b51cabb26f07871bfa026a9473a14" title="Interpret this key as a PublicKey.">toPublicKey()</a> for the public version of this method </dd></dl>

</div>
</div>
<a class="anchor" id="a095477c51284e49f6fbf5ed71bbabf46"></a><!-- doxytag: member="QCA::PKey::toDSAPrivateKey" ref="a095477c51284e49f6fbf5ed71bbabf46" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classQCA_1_1DSAPrivateKey.html">DSAPrivateKey</a> QCA::PKey::toDSAPrivateKey </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Interpret this key as a <a class="el" href="classQCA_1_1DSAPrivateKey.html" title="Digital Signature Algorithm Private Key.">DSAPrivateKey</a>. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>This function is essentially a convenience cast - if the key was created as an RSA key, this function cannot turn it into a DSA key.</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classQCA_1_1PKey.html#a62d01121d3790d4d80cd4e3d60fa0ee6" title="Interpret this key as a PrivateKey.">toPrivateKey()</a> for the public version of this method </dd></dl>

</div>
</div>
<a class="anchor" id="abb07b767d8d464bc8d782f00059e4054"></a><!-- doxytag: member="QCA::PKey::toDHPublicKey" ref="abb07b767d8d464bc8d782f00059e4054" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classQCA_1_1DHPublicKey.html">DHPublicKey</a> QCA::PKey::toDHPublicKey </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Interpret this key as an <a class="el" href="classQCA_1_1DHPublicKey.html" title="Diffie-Hellman Public Key.">DHPublicKey</a>. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>This function is essentially a convenience cast - if the key was created as a DSA key, this function cannot turn it into a DH key.</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classQCA_1_1PKey.html#a637b51cabb26f07871bfa026a9473a14" title="Interpret this key as a PublicKey.">toPublicKey()</a> for the public version of this method </dd></dl>

</div>
</div>
<a class="anchor" id="aa98d76967880530b5367609d01baf010"></a><!-- doxytag: member="QCA::PKey::toDHPrivateKey" ref="aa98d76967880530b5367609d01baf010" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classQCA_1_1DHPrivateKey.html">DHPrivateKey</a> QCA::PKey::toDHPrivateKey </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Interpret this key as a <a class="el" href="classQCA_1_1DHPrivateKey.html" title="Diffie-Hellman Private Key.">DHPrivateKey</a>. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>This function is essentially a convenience cast - if the key was created as a DSA key, this function cannot turn it into a DH key.</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classQCA_1_1PKey.html#a62d01121d3790d4d80cd4e3d60fa0ee6" title="Interpret this key as a PrivateKey.">toPrivateKey()</a> for the public version of this method </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="qca__publickey_8h_source.html">qca_publickey.h</a></li>
</ul>
</div>
<hr class="footer"/><address style="text-align: right;"><small>Generated on Sat Nov 27 13:41:18 2010 for Qt Cryptographic Architecture by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.3 </small></address>
</body>
</html>
